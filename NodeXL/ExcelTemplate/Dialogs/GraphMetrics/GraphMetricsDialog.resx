<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="lnkBrandesFastCentralities.Tag" xml:space="preserve">
    <value>A vertex that occurs on many shortest paths between other vertices has a larger betweenness centrality than vertices that do not.  Betweenness centrality is defined in this article:
	
http://en.wikipedia.org/wiki/Centrality#Betweenness_centrality

NodeXL uses the algorithm described in the paper "A Faster Algorithm for Betweenness Centrality," by Ulrik Brandes.  The paper can be found here:

http://www.inf.uni-konstanz.de/algo/publications/b-fabc-01.pdf

The algorithm successfully handles self-loops and duplicate edges.

The closeness centrality of a vertex is the average distance (along the shortest path) between the vertex and all other vertices reachable from it.  It is defined in this article:

http://en.wikipedia.org/wiki/Centrality#Closeness_centrality

(You can press Ctrl-C to copy these details to the clipboard.)</value>
  </data>
  <data name="lnkEigenvectorCentrality.Tag" xml:space="preserve">
    <value>Eigenvector centrality is defined in this article:

http://en.wikipedia.org/wiki/Eigenvector_centrality#Eigenvector_centrality

From the article:

"Eigenvector centrality is a measure of the importance of a node in a network. It assigns relative scores to all nodes in the network based on the principle that connections to high-scoring nodes contribute more to the score of the node in question than equal connections to low-scoring nodes."

(You can press Ctrl-C to copy these details to the clipboard.)</value>
  </data>
  <data name="lnkDegree.Tag" xml:space="preserve">
    <value>In an undirected graph, a vertex's degree is the number of edges incident to the vertex.  In a directed graph, degree is undefined and is not computed.

Self-loops are counted in degree metrics.  Duplicate edges cause the degree metrics to be inaccurate.  Inaccurate degree metrics are highlighted.</value>
  </data>
  <data name="lnkOutDegree.Tag" xml:space="preserve">
    <value>In a directed graph, a vertex's out-degree is the number of outgoing edges incident to the vertex.  In an undirected graph, out-degree is undefined and is not computed.

Self-loops are counted in degree metrics.  Duplicate edges cause the degree metrics to be inaccurate.  Inaccurate degree metrics are highlighted.</value>
  </data>
  <data name="lnkInDegree.Tag" xml:space="preserve">
    <value>In a directed graph, a vertex's in-degree is the number of incoming edges incident to the vertex.  In an undirected graph, in-degree is undefined and is not computed.

Self-loops are counted in degree metrics.  Duplicate edges cause the degree metrics to be inaccurate.  Inaccurate degree metrics are highlighted.</value>
  </data>
  <data name="lnkPageRank.Tag" xml:space="preserve">
    <value>PageRank measures the importance of each vertex within the graph using a link analysis algorithm developed by Larry Page.  It is described here:

http://en.wikipedia.org/wiki/PageRank

(You can press Ctrl-C to copy these details to the clipboard.)</value>
  </data>
  <data name="lnkClusteringCoefficient.Tag" xml:space="preserve">
    <value>Clustering coefficient is defined in this article:

http://en.wikipedia.org/wiki/Clustering_coefficient

From the article:

"The clustering coefficient of a vertex in a graph quantifies how close the vertex and its neighbors are to being a clique (complete graph)."

Self-loops, which would render the clustering coefficients invalid, are skipped.  Duplicate edges cause the clustering coefficients to be inaccurate.  Inaccurate clustering coefficients are highlighted.

(You can press Ctrl-C to copy these details to the clipboard.)</value>
  </data>
</root>